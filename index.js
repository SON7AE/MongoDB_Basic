// 1. 몽고DB의 시작

// 몽고DB는 관계형 데이터베이스가 아니라 도큐먼트 지향 데이터베이스이다. 관계형 모델을 사용하지 않는 주된 이유는 분산확장(scale-out)을 쉽게 하기 위함이지만 다른 이점도 있다.
// 도큐먼트 지향 데이터베이스에서는 행 개념 대신에 보다 유연한 모델인 도큐먼트(document)를 사용한다. 내장 도큐먼트와 배열을 허용함으로써 도큐먼트 지향 모델은 복잡한 계층 관계를 하나의 레코드로 표현할 수 있다.
// 또한 몽고DB에서는 키와 값을 미리 정의하지 않는다. 따라서 고정된 스키마가 없다. 고정된 스키마가 없으므로 필요할 띠마다 쉽게 필드를 추가하거나 제거할 수 있다.

// 저장할 데이터가 증가함에 따라 개발자는 '데이터베이스를 어떻게 확장할 것인가'와 같은 어려운 의사 결정을 해야하는 상황에 직면한다.
// 데이터베이스의 확장은 결국 더 큰 장비로 성능확장할 지 혹은 여러 장비에 데이터를 나눠 분산 확장할지 결졍해야 하는 갈림길에 서게 한다.

// 몽고DB 데이터의 기본 단위는 도큐먼트이며, 이는 관계형 데이터베이스의 행과 유사하다.
// 같은 맥락에서 컬렉션(collection)은 동적 스키마(dynamic schema)가 있는 테이블과 같다.
// 몽고DB의 단일 인스턴스는 자체적인 컬렉션을 갖는 여러 개의 독립적인 데이터베이스를 호스팅한다.
// 몽고DB는 몽고 셸(mongo shell)이라는 간단하지만 강력한 도구와 함께 배포된다. 몽고 셸은 몽고DB 인스턴스를 관리하고 몽고DB 쿼리 언어로 데이터를 조작하기 위한 내장 지원을 제공한다.
// 또한 사용자가 다양한 목적으로 자신의 스크립트를 만들고 로드할 수 있는 완전한 기능의 자바스크립트 해석가이다.

// ----------------------------------------------------------------------------------------------------

// 1-1. 도큐먼트

// 몽고DB의 핵심은 정렬된 키와 연결된 값의 집합으로 이뤄진 도큐먼트다.
// 도큐먼트 표현방식은 프로그래밍 언어마다 다르지만 대부분의 언어는 맵(map), 해시(hash), 딕셔너리(dictionary)와 같이 도큐먼트를 자연스럽게 표현하는 자료구조를 가진다.
// 예를 들어 자바스크립트에서 도큐먼트는 객체로 표현된다. 도큐먼트의 값은 단지 blob형이 아니다.
// * Blob 객체는 파일류의 불변하는 미가공 데이터를 나타냅니다. 텍스트와 이진 데이터의 형태로 읽을 수 있으며, ReadableStream으로 변환한 후 스트림 메서드를 사용해 데이터를 처리할 수도 있습니다.

// 몽고DB는 데이터형과 대소문자를 구별한다. 또한 몽고DB에서는 키가 중복될 수 없음을 기억하자.

// ----------------------------------------------------------------------------------------------------

// 1-2. 컬렉션

// 컬렉션은 도큐먼트의 모음이다.
// 몽고DB의 도큐먼트가 관계형 데이터베이스의 행에 대응된다면, 컬렉션은 테이블에 대응된다고 볼 수 있다.
// 컬렉션은 동적 스키마를 가진다. 하나의 컬렉션 내 도큐먼트들이 모두 다른 구조를 가질 수 있다는 의미이다.
// 도큐먼트들의 키, 키의 개수, 데이터형의 값은 모두 다르다. 다른 구조의 도큐먼트라도 같은 컬렉션에 저장할 수 있는데 "왜 별도의 컬렉션이 필요하지?"라고 생각할 수 있다.
// 도큐먼트에 별도의 스키마가 필요 없는데 왜 하나 이상의 컬렉션이 필요할까? 몇 가지 합당한 이유가 있다.

// - 같은 컬렉션에 다른 종류의 도큐먼트를 저장하면, 개발자와 관리자에게 번거로운 일이 생길 수도 있다. 각 쿼리가 특정 스키마를 고수하는 도큐먼트를 반환하는지, 혹은 쿼리한 코드가 다른 구조의 도큐먼트를 다룰 수 있는지 확실히 확인하자.
// 예를 들어 블로그 게시물을 쿼리한 데이터 중 작성자 데이터만 제거하려면 상당히 번거롭다.
// - 컬렉션별로 목록을 뽑으면 한 컬렉션 내 특정 데이터형별로 쿼리해서 목록을 뽑을 때보다 훨씬 빠르다.
// - 같은 종류의 데이터를 하나의 컬렉션에 모아두면 데이터 지역상(data locality)에도 좋다. 블로그 게시물 여러 개를 뽑는 경우, 게시물과 저자 정보가 섞인 컬렉션보다 게시물만 들어 있는 컬렉션에서 뽑을 때 디스크 탐색 시간이 더 짧다.
// - 인덱스를 만들면 도큐먼트는 특정 구조를 가져야 한다. 이러한 인덱스는 컬렉션별로 정의한다. 같은 유형의 도큐먼트를 하나의 컬렉션에 넣음으로써 컬렉션을 효율적으로 인덱싱할 수 있다.

// ----------------------------------------------------------------------------------------------------

// 1-3. 네이밍

// 컬렉션은 이름으로 식별된다.
// 컬렉션명은 어떤 UTF-8 문자열이든 쓸 수 있지만 몇 가지 제약조건이 있다.
// - 빈 문자열("")은 유효한 컬렉션명이 아니다.
// - \0(null 문자)은 컬렉션명의 끝을 나타내는 문자이므로 컬렉션명에 사용할 수 없다.
// - system.으로 시작하는 컬렉션명은 시스템 컬렉션에서 사용하는 예약어이므로 사용할 수 없다.
// - 사용자가 만든 컬렉션은 이름에 예약어인 $을/를 포함할 수 없다.

// 1-3-1. 서브컬렉션

// 서브컬렉션의 네임스페이스에 .(마침표) 문자를 사용해 컬렉션을 체계화한다.

// ----------------------------------------------------------------------------------------------------

// 1-4. 데이터베이스

// 몽고DB는 컬렉션에 도큐먼트를 그룹화할 뿐 아니라 데이터베이스에 컬렉션을 그룹 지어 놓는다.
// 몽고DB의 단일 인스턴스는 여러 데이터베이스를 호스팅할 수 있으며, 각 데이터베이스를 완전히 독립적으로 취급할 수 있다.
// 한 애플리케이션의 데이터를 동일한 데이터베이스에 저장하는 것은 좋은 방법이다.
